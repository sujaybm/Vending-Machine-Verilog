//created 26-Nov-2019, last edited 26-Nov-2019
//Final code for the vending machine design.
//Literal usage of LEDs and pushbuttons.
//Designed for Verilog to be used on a Terasic FPGA.

/* ================ COMPILER DEFINITIONS ================ */
`timescale 10ns/1ns

`define state0 3'b000  //reset
`define state1 3'b001  //ask user to select product
`define state2 3'b010  //display cost for the selected product and confirm
`define state3 3'b011  //allow user to input currency
`define state4 3'b100  //calculate if enough money
`define state5 3'b101  //ask for receipt or to cancel
`define state6 3'b110  //release product

//must be in BCD format
`define candybar    4'b0001
`define cheetos     4'b0010
`define frappuccino 4'b0011
`define coke        4'b0100
`define water       4'b0101

//costs of all products, multiplied by 100 to be integers
`define c_cand 325
`define c_chee 275
`define c_frap 350
`define c_coke 150
`define c_wate 100

/* ================ 7 SEGMENT DISPLAY ================ */
module display7 (in_bcd, seven);
  input [3:0] in_bcd;
  output [6:0] seven;

  reg [6:0] seven;
  
  always @ (in_bcd) begin
    case (in_bcd)
      4'b0000 : seven = 7'b0111111;  //zero
      4'b0001 : seven = 7'b0000110;  //one
      4'b0010 : seven = 7'b1011011;  //two
      4'b0011 : seven = 7'b1001111;  //three
      4'b0100 : seven = 7'b1100110;  //four
      4'b0101 : seven = 7'b1101101;  //five
      4'b0110 : seven = 7'b1111101;  //six
      4'b0111 : seven = 7'b0000111;  //seven
      4'b1000 : seven = 7'b1111111;  //eight
      4'b1001 : seven = 7'b1101111;  //nine
      default : seven = 7'b0000000;
    endcase
  end
endmodule

/* ================ MAIN FUNCTION ================ */
module main (clk, in_vec, out_led, hex5, hex2, hex1, hex0, hex27);
input clk;
input [11:0] in_vec;
output [8:0] out_led;
output [6:0] hex5;
output [6:0] hex2;
output [6:0] hex1;
output [6:0] hex0;
output hex27;

wire clk;
wire [11:0] in_vec;  //explicit variables for the input buttons
reg [8:0] out_led;  //output to turn on certain LEDs
wire [6:0] hex5;
wire [6:0] hex2;
wire [6:0] hex1;
wire [6:0] hex0;
reg hex27;

reg [2:0] current_state;
reg [2:0] next_state;
reg error_flag;

reg [3:0] product;  //current product chosen
integer current_amount;  //current amount the user has put in so far
integer prod_cost;  //cost of the product once selection occurs

//variables for the 7 segment display
reg [3:0] dsp_product;  //should display on HEX5
reg [3:0] dsp_ones;  //should display on HEX2
reg [3:0] dsp_tens;  //should display on HEX1
reg [3:0] dsp_hund;  //should display on HEX0

reg [4:0] selector2;  //selector for state2 mux
reg [2:0] selector4;  //selector for state4 mux

reg user_input_interrupt;  //check to see if the user has pressed a button, device should
                               //not move forward if a button hasn't been pressed

//these values go high if their corresponding button signals are set high
reg b_cand, b_chee, b_frap, b_coke, b_wate;  //product selection for state1
reg confirm2, cancel2;  //confirm or cancel for state2
reg amount25, amount50, amount100;  //currency amounts for state3
reg print5, cancel5;  //print receipt or cancel for state5

//these values will turn on their respective LEDs
reg led_state0;

display7 hold5 (.in_bcd(dsp_product), .seven(hex5));
display7 hold2 (.in_bcd(dsp_ones), .seven(hex2));
display7 hold1 (.in_bcd(dsp_tens), .seven(hex1));
display7 hold0 (.in_bcd(dsp_hund), .seven(hex0));

initial begin
  current_state = `state0; next_state = `state0; error_flag = 0;
  hex27 = 1;  //the decimal point should always be on
  user_input_interrupt = 0;
end

/* ================ BUTTON DECDODING ================ */
always @ (negedge clk) begin
  if ((b_cand == 0) && in_vec[11])
    b_cand = 1;
  if ((b_chee == 0) && in_vec[10])
    b_chee = 1;
  if ((b_frap == 0) && in_vec[9])
    b_frap = 1;
  if ((b_coke == 0) && in_vec[8])
    b_coke = 1;
  if ((b_wate == 0) && in_vec[7])
    b_wate = 1;

  if ((confirm2 == 0) && in_vec[6])
    confirm2 = 1;
  if ((cancel2 == 0) && in_vec[5])
    cancel2 = 1;
  
  if ((amount25 == 0) && in_vec[4])
    amount25 = 1;
  if ((amount50 == 0) && in_vec[3])
    amount50 = 1;
  if ((amount100 == 0) && in_vec[2])
    amount100 = 1;

  if ((print5 == 0) && in_vec[1])
    print5 = 1;
  if ((cancel5 == 0) && in_vec[0])
    cancel5 = 1;
end

/* ================ ERROR FLAG ================ */
always @ (posedge error_flag)
begin : error_led
  //bring LED on the FPGA board high
end

/* ================ BCD CONVERTER ================ */
task bcd_conv;
  input in_dec;
  output out_bcd2;
  output out_bcd1;
  output out_bcd0;
  
  integer ones, tens, hund;
  
  begin
    ones = in_dec / 100;
    tens = (in_dec % 100) / 10;
    hund = (in_dec % 10);
    case (ones)
      1: out_bcd2 = 0001;
      2: out_bcd2 = 0010;
      3: out_bcd2 = 0011;
      4: out_bcd2 = 0100;
      5: out_bcd2 = 0101;
      6: out_bcd2 = 0110;
      7: out_bcd2 = 0111;
      8: out_bcd2 = 1000;
      9: out_bcd2 = 1001;
      default: out_bcd2 = 0000;
    endcase
    case (tens)
      1: out_bcd1 = 0001;
      2: out_bcd1 = 0010;
      3: out_bcd1 = 0011;
      4: out_bcd1 = 0100;
      5: out_bcd1 = 0101;
      6: out_bcd1 = 0110;
      7: out_bcd1 = 0111;
      8: out_bcd1 = 1000;
      9: out_bcd1 = 1001;
      default: out_bcd1 = 0000;
    endcase
    case (hund)
      1: out_bcd0 = 0001;
      2: out_bcd0 = 0010;
      3: out_bcd0 = 0011;
      4: out_bcd0 = 0100;
      5: out_bcd0 = 0101;
      6: out_bcd0 = 0110;
      7: out_bcd0 = 0111;
      8: out_bcd0 = 1000;
      9: out_bcd0 = 1001;
      default: out_bcd0 = 0000;
    endcase
  end
endtask

/* ================ STATE UPDATE ================ */
always @ (posedge clk)
begin : state_update
  if (user_input_interrupt) begin
    current_state = next_state;
    user_input_interrupt = 0;
  end
end

/* ================ NEXT STATE LOGIC ================ */
always @ (current_state, current_amount, posedge confirm2)
begin : next_state_logic
  case (current_state)
    `state0: next_state = `state1;
    `state1: next_state = `state2;
    `state2: begin
               if (confirm2)
                 next_state = `state3;
               else
                 next_state = `state1;
               confirm2 = 0;
               cancel2 = 0;
             end
    `state3: next_state = `state4;
    `state4: begin
               if (current_amount >= prod_cost)
                 next_state = `state5;
               else
                 next_state = `state3;
             end
    `state5: next_state = `state6;
    `state6: next_state = `state0;
    default: begin
               next_state = `state0;
               error_flag = 1;
             end
  endcase
end  //end next_state_logic

/* ================ COMBINATIONAL OUTPUT LOGIC ================ */
always @ (current_state)
begin : output_logic
  case (current_state)
    `state0: begin
               product = 4'b0000; current_amount = 0; prod_cost = 0;
               dsp_product = 0; dsp_ones = 0; dsp_tens = 0; dsp_hund = 0;
               selector2 = 5'b00000; selector4 = 3'b000;
               b_cand = 0; b_chee = 0; b_frap = 0; b_coke = 0; b_wate = 0;
               confirm2 = 0; cancel2 = 0;
               amount25 = 0; amount50 = 0; amount100 = 0;
               print5 = 0; cancel5 = 0;
               #1 user_input_interrupt = 1;  //SM should move to State1 automatically
             end
    `state1: begin
               //bring state1 LED high
               //cardboard should have 5 buttons to select a prodcut
             end
    `state2: begin
               selector2 = {b_cand, b_chee, b_frap, b_coke, b_wate};
               case (selector2)
                 5'b10000 : begin product = `candybar;
                            prod_cost = `c_cand;
                            end
                 5'b01000 : begin product = `cheetos;
                            prod_cost = `c_chee;
                            end
                 5'b00100 : begin product = `frappuccino;
                            prod_cost = `c_frap;
                            end
                 5'b00010 : begin product = `coke;
                            prod_cost = `c_coke;
                            end
                 5'b00001 : begin product = `water;
                            prod_cost = `c_wate;
                            end
                 default  : begin product = 3'b000;
                            prod_cost = 0;
                            end
               endcase
               b_cand = 0; b_chee = 0; b_frap = 0; b_coke = 0; b_wate = 0;
               dsp_product = product;
               bcd_conv(prod_cost, dsp_ones, dsp_tens, dsp_hund);
             end
    `state3: begin
               bcd_conv(prod_cost - current_amount, dsp_ones, dsp_tens, dsp_hund);
             end
    `state4: begin
               selector4 = {amount25, amount50, amount100};
               case (selector4)
                 3'b100 : current_amount = current_amount + 25;
                 3'b010 : current_amount = current_amount + 50;
                 3'b001 : current_amount = current_amount + 100;
                 default: error_flag = 1;
               endcase
               amount25 = 0; amount50 = 0; amount100 = 0;
               //timing note: next_state_logic for state4 must be fully calculated before next clock cycle
               #1 user_input_interrupt = 1;  //device must go to next state directly, not waiting on user
             end
    `state5: begin
               //bring state5 LED high
               //cardboad asks "print reciept or cancel"
             end
    `state6: begin
               if (print5)
                 bcd_conv(current_amount - prod_cost, dsp_ones, dsp_tens, dsp_hund);
               else if (cancel5)
                 bcd_conv(current_amount, dsp_ones, dsp_tens, dsp_hund);
               else error_flag = 1;
               print5 = 0; cancel5 = 0;
               #3000 user_input_interrupt = 1;  //SMshould move to State0 automatically
             end
    default: begin
               error_flag = 1;
             end
  endcase
end  //end output_logic

endmodule //end main
